## 为什么可以先唤醒线程后阻塞线程
答：
因为`unpark()`获得了一个凭证，之后再调用`park()`方法，就可以名正言顺的凭证消费，所以不会阻塞。

## 为什么唤醒两次后阻塞两次，但是最终结果还是会阻塞线程？
因为凭证的数量最多为1，连续调用两次`unpark()`和调用一次`unpark()`效果一样，只会增加一个凭证；
而调用两次`park()`却需要两个凭证，证不够，不能放行。